// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notes.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNote = `-- name: CreateNote :one
INSERT INTO notes (title, template_id, owner_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id, title, template_id, owner_id, status, created_at, updated_at
`

type CreateNoteParams struct {
	Title      string      `db:"title" json:"title"`
	TemplateID pgtype.UUID `db:"template_id" json:"template_id"`
	OwnerID    pgtype.UUID `db:"owner_id" json:"owner_id"`
	Status     string      `db:"status" json:"status"`
}

func (q *Queries) CreateNote(ctx context.Context, arg *CreateNoteParams) (*Note, error) {
	row := q.db.QueryRow(ctx, createNote,
		arg.Title,
		arg.TemplateID,
		arg.OwnerID,
		arg.Status,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TemplateID,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createSection = `-- name: CreateSection :one
INSERT INTO sections (note_id, field_id, content)
VALUES ($1, $2, $3)
RETURNING id, note_id, field_id, content
`

type CreateSectionParams struct {
	NoteID  pgtype.UUID `db:"note_id" json:"note_id"`
	FieldID pgtype.UUID `db:"field_id" json:"field_id"`
	Content string      `db:"content" json:"content"`
}

func (q *Queries) CreateSection(ctx context.Context, arg *CreateSectionParams) (*Section, error) {
	row := q.db.QueryRow(ctx, createSection, arg.NoteID, arg.FieldID, arg.Content)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.FieldID,
		&i.Content,
	)
	return &i, err
}

const deleteNote = `-- name: DeleteNote :exec
DELETE FROM notes
WHERE id = $1
`

func (q *Queries) DeleteNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteNote, id)
	return err
}

const deleteSectionsByNote = `-- name: DeleteSectionsByNote :exec
DELETE FROM sections
WHERE note_id = $1
`

func (q *Queries) DeleteSectionsByNote(ctx context.Context, noteID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSectionsByNote, noteID)
	return err
}

const getNoteByID = `-- name: GetNoteByID :one
SELECT
    n.id, n.title, n.template_id, n.owner_id, n.status, n.created_at, n.updated_at,
    t.name AS template_name,
    a.first_name,
    a.last_name,
    a.thumbnail AS owner_thumbnail
FROM notes n
JOIN templates t ON t.id = n.template_id
JOIN accounts a ON a.id = n.owner_id
WHERE n.id = $1
`

type GetNoteByIDRow struct {
	ID             pgtype.UUID        `db:"id" json:"id"`
	Title          string             `db:"title" json:"title"`
	TemplateID     pgtype.UUID        `db:"template_id" json:"template_id"`
	OwnerID        pgtype.UUID        `db:"owner_id" json:"owner_id"`
	Status         string             `db:"status" json:"status"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TemplateName   string             `db:"template_name" json:"template_name"`
	FirstName      string             `db:"first_name" json:"first_name"`
	LastName       string             `db:"last_name" json:"last_name"`
	OwnerThumbnail pgtype.Text        `db:"owner_thumbnail" json:"owner_thumbnail"`
}

func (q *Queries) GetNoteByID(ctx context.Context, id pgtype.UUID) (*GetNoteByIDRow, error) {
	row := q.db.QueryRow(ctx, getNoteByID, id)
	var i GetNoteByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TemplateID,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TemplateName,
		&i.FirstName,
		&i.LastName,
		&i.OwnerThumbnail,
	)
	return &i, err
}

const listNotes = `-- name: ListNotes :many
SELECT
    n.id, n.title, n.template_id, n.owner_id, n.status, n.created_at, n.updated_at,
    t.name AS template_name,
    a.first_name,
    a.last_name,
    a.thumbnail AS owner_thumbnail
FROM notes n
JOIN templates t ON t.id = n.template_id
JOIN accounts a ON a.id = n.owner_id
WHERE (NULLIF($1::text, '') IS NULL OR n.status = $1)
  AND ($2::uuid IS NULL OR n.template_id = $2)
  AND ($3::uuid IS NULL OR n.owner_id = $3)
  AND (NULLIF($4::text, '') IS NULL OR n.title ILIKE '%' || $4 || '%')
ORDER BY n.updated_at DESC
`

type ListNotesParams struct {
	Column1 string      `db:"column_1" json:"column_1"`
	Column2 pgtype.UUID `db:"column_2" json:"column_2"`
	Column3 pgtype.UUID `db:"column_3" json:"column_3"`
	Column4 string      `db:"column_4" json:"column_4"`
}

type ListNotesRow struct {
	ID             pgtype.UUID        `db:"id" json:"id"`
	Title          string             `db:"title" json:"title"`
	TemplateID     pgtype.UUID        `db:"template_id" json:"template_id"`
	OwnerID        pgtype.UUID        `db:"owner_id" json:"owner_id"`
	Status         string             `db:"status" json:"status"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TemplateName   string             `db:"template_name" json:"template_name"`
	FirstName      string             `db:"first_name" json:"first_name"`
	LastName       string             `db:"last_name" json:"last_name"`
	OwnerThumbnail pgtype.Text        `db:"owner_thumbnail" json:"owner_thumbnail"`
}

func (q *Queries) ListNotes(ctx context.Context, arg *ListNotesParams) ([]*ListNotesRow, error) {
	rows, err := q.db.Query(ctx, listNotes,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListNotesRow
	for rows.Next() {
		var i ListNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TemplateID,
			&i.OwnerID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TemplateName,
			&i.FirstName,
			&i.LastName,
			&i.OwnerThumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSectionsByNote = `-- name: ListSectionsByNote :many
SELECT
    s.id, s.note_id, s.field_id, s.content,
    f.label,
    f."order",
    f.is_required
FROM sections s
JOIN fields f ON f.id = s.field_id
WHERE s.note_id = $1
ORDER BY f."order" ASC
`

type ListSectionsByNoteRow struct {
	ID         pgtype.UUID `db:"id" json:"id"`
	NoteID     pgtype.UUID `db:"note_id" json:"note_id"`
	FieldID    pgtype.UUID `db:"field_id" json:"field_id"`
	Content    string      `db:"content" json:"content"`
	Label      string      `db:"label" json:"label"`
	Order      int32       `db:"order" json:"order"`
	IsRequired bool        `db:"is_required" json:"is_required"`
}

func (q *Queries) ListSectionsByNote(ctx context.Context, noteID pgtype.UUID) ([]*ListSectionsByNoteRow, error) {
	rows, err := q.db.Query(ctx, listSectionsByNote, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListSectionsByNoteRow
	for rows.Next() {
		var i ListSectionsByNoteRow
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.FieldID,
			&i.Content,
			&i.Label,
			&i.Order,
			&i.IsRequired,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNote = `-- name: UpdateNote :one
UPDATE notes
SET
    title = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, template_id, owner_id, status, created_at, updated_at
`

type UpdateNoteParams struct {
	ID    pgtype.UUID `db:"id" json:"id"`
	Title string      `db:"title" json:"title"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg *UpdateNoteParams) (*Note, error) {
	row := q.db.QueryRow(ctx, updateNote, arg.ID, arg.Title)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TemplateID,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateNoteStatus = `-- name: UpdateNoteStatus :one
UPDATE notes
SET
    status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, template_id, owner_id, status, created_at, updated_at
`

type UpdateNoteStatusParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	Status string      `db:"status" json:"status"`
}

func (q *Queries) UpdateNoteStatus(ctx context.Context, arg *UpdateNoteStatusParams) (*Note, error) {
	row := q.db.QueryRow(ctx, updateNoteStatus, arg.ID, arg.Status)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TemplateID,
		&i.OwnerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateSectionContent = `-- name: UpdateSectionContent :one
UPDATE sections
SET content = $2
WHERE id = $1
RETURNING id, note_id, field_id, content
`

type UpdateSectionContentParams struct {
	ID      pgtype.UUID `db:"id" json:"id"`
	Content string      `db:"content" json:"content"`
}

func (q *Queries) UpdateSectionContent(ctx context.Context, arg *UpdateSectionContentParams) (*Section, error) {
	row := q.db.QueryRow(ctx, updateSectionContent, arg.ID, arg.Content)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.FieldID,
		&i.Content,
	)
	return &i, err
}
