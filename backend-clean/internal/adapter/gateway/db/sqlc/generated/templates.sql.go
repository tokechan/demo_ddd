// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: templates.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkTemplateInUse = `-- name: CheckTemplateInUse :one
SELECT EXISTS (
    SELECT 1 FROM notes WHERE template_id = $1
) AS is_used
`

func (q *Queries) CheckTemplateInUse(ctx context.Context, templateID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkTemplateInUse, templateID)
	var is_used bool
	err := row.Scan(&is_used)
	return is_used, err
}

const createField = `-- name: CreateField :one
INSERT INTO fields (template_id, label, "order", is_required)
VALUES ($1, $2, $3, $4)
RETURNING id, template_id, label, "order", is_required
`

type CreateFieldParams struct {
	TemplateID pgtype.UUID `db:"template_id" json:"template_id"`
	Label      string      `db:"label" json:"label"`
	Order      int32       `db:"order" json:"order"`
	IsRequired bool        `db:"is_required" json:"is_required"`
}

func (q *Queries) CreateField(ctx context.Context, arg *CreateFieldParams) (*Field, error) {
	row := q.db.QueryRow(ctx, createField,
		arg.TemplateID,
		arg.Label,
		arg.Order,
		arg.IsRequired,
	)
	var i Field
	err := row.Scan(
		&i.ID,
		&i.TemplateID,
		&i.Label,
		&i.Order,
		&i.IsRequired,
	)
	return &i, err
}

const createTemplate = `-- name: CreateTemplate :one
INSERT INTO templates (name, owner_id)
VALUES ($1, $2)
RETURNING id, name, owner_id, updated_at
`

type CreateTemplateParams struct {
	Name    string      `db:"name" json:"name"`
	OwnerID pgtype.UUID `db:"owner_id" json:"owner_id"`
}

func (q *Queries) CreateTemplate(ctx context.Context, arg *CreateTemplateParams) (*Template, error) {
	row := q.db.QueryRow(ctx, createTemplate, arg.Name, arg.OwnerID)
	var i Template
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteField = `-- name: DeleteField :exec
DELETE FROM fields
WHERE id = $1
`

func (q *Queries) DeleteField(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteField, id)
	return err
}

const deleteFieldsByTemplate = `-- name: DeleteFieldsByTemplate :exec
DELETE FROM fields
WHERE template_id = $1
`

func (q *Queries) DeleteFieldsByTemplate(ctx context.Context, templateID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFieldsByTemplate, templateID)
	return err
}

const deleteTemplate = `-- name: DeleteTemplate :exec
DELETE FROM templates
WHERE id = $1
`

func (q *Queries) DeleteTemplate(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTemplate, id)
	return err
}

const getTemplateByID = `-- name: GetTemplateByID :one
SELECT
    t.id, t.name, t.owner_id, t.updated_at,
    a.first_name AS owner_first_name,
    a.last_name AS owner_last_name,
    a.thumbnail AS owner_thumbnail,
    EXISTS (
        SELECT 1
        FROM notes n
        WHERE n.template_id = t.id
        LIMIT 1
    ) AS is_used
FROM templates t
JOIN accounts a ON a.id = t.owner_id
WHERE t.id = $1
`

type GetTemplateByIDRow struct {
	ID             pgtype.UUID        `db:"id" json:"id"`
	Name           string             `db:"name" json:"name"`
	OwnerID        pgtype.UUID        `db:"owner_id" json:"owner_id"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	OwnerFirstName string             `db:"owner_first_name" json:"owner_first_name"`
	OwnerLastName  string             `db:"owner_last_name" json:"owner_last_name"`
	OwnerThumbnail pgtype.Text        `db:"owner_thumbnail" json:"owner_thumbnail"`
	IsUsed         bool               `db:"is_used" json:"is_used"`
}

func (q *Queries) GetTemplateByID(ctx context.Context, id pgtype.UUID) (*GetTemplateByIDRow, error) {
	row := q.db.QueryRow(ctx, getTemplateByID, id)
	var i GetTemplateByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.UpdatedAt,
		&i.OwnerFirstName,
		&i.OwnerLastName,
		&i.OwnerThumbnail,
		&i.IsUsed,
	)
	return &i, err
}

const listFieldsByTemplate = `-- name: ListFieldsByTemplate :many
SELECT id, template_id, label, "order", is_required
FROM fields
WHERE template_id = $1
ORDER BY "order" ASC
`

func (q *Queries) ListFieldsByTemplate(ctx context.Context, templateID pgtype.UUID) ([]*Field, error) {
	rows, err := q.db.Query(ctx, listFieldsByTemplate, templateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Field
	for rows.Next() {
		var i Field
		if err := rows.Scan(
			&i.ID,
			&i.TemplateID,
			&i.Label,
			&i.Order,
			&i.IsRequired,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTemplates = `-- name: ListTemplates :many
SELECT
    t.id, t.name, t.owner_id, t.updated_at,
    a.first_name AS owner_first_name,
    a.last_name AS owner_last_name,
    a.thumbnail AS owner_thumbnail,
    EXISTS (
        SELECT 1
        FROM notes n
        WHERE n.template_id = t.id
        LIMIT 1
    ) AS is_used
FROM templates t
JOIN accounts a ON a.id = t.owner_id
WHERE ($1::uuid IS NULL OR t.owner_id = $1)
  AND ($2::text IS NULL OR t.name ILIKE '%' || $2 || '%')
ORDER BY t.updated_at DESC
`

type ListTemplatesParams struct {
	Column1 pgtype.UUID `db:"column_1" json:"column_1"`
	Column2 string      `db:"column_2" json:"column_2"`
}

type ListTemplatesRow struct {
	ID             pgtype.UUID        `db:"id" json:"id"`
	Name           string             `db:"name" json:"name"`
	OwnerID        pgtype.UUID        `db:"owner_id" json:"owner_id"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	OwnerFirstName string             `db:"owner_first_name" json:"owner_first_name"`
	OwnerLastName  string             `db:"owner_last_name" json:"owner_last_name"`
	OwnerThumbnail pgtype.Text        `db:"owner_thumbnail" json:"owner_thumbnail"`
	IsUsed         bool               `db:"is_used" json:"is_used"`
}

func (q *Queries) ListTemplates(ctx context.Context, arg *ListTemplatesParams) ([]*ListTemplatesRow, error) {
	rows, err := q.db.Query(ctx, listTemplates, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListTemplatesRow
	for rows.Next() {
		var i ListTemplatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.UpdatedAt,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerThumbnail,
			&i.IsUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateField = `-- name: UpdateField :one
UPDATE fields
SET
    label = $2,
    "order" = $3,
    is_required = $4
WHERE id = $1
RETURNING id, template_id, label, "order", is_required
`

type UpdateFieldParams struct {
	ID         pgtype.UUID `db:"id" json:"id"`
	Label      string      `db:"label" json:"label"`
	Order      int32       `db:"order" json:"order"`
	IsRequired bool        `db:"is_required" json:"is_required"`
}

func (q *Queries) UpdateField(ctx context.Context, arg *UpdateFieldParams) (*Field, error) {
	row := q.db.QueryRow(ctx, updateField,
		arg.ID,
		arg.Label,
		arg.Order,
		arg.IsRequired,
	)
	var i Field
	err := row.Scan(
		&i.ID,
		&i.TemplateID,
		&i.Label,
		&i.Order,
		&i.IsRequired,
	)
	return &i, err
}

const updateTemplate = `-- name: UpdateTemplate :one
UPDATE templates
SET
    name = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, owner_id, updated_at
`

type UpdateTemplateParams struct {
	ID   pgtype.UUID `db:"id" json:"id"`
	Name string      `db:"name" json:"name"`
}

func (q *Queries) UpdateTemplate(ctx context.Context, arg *UpdateTemplateParams) (*Template, error) {
	row := q.db.QueryRow(ctx, updateTemplate, arg.ID, arg.Name)
	var i Template
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.UpdatedAt,
	)
	return &i, err
}
